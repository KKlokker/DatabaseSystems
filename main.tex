\documentclass[12pt, a4paper]{article}
\usepackage{caption}
\usepackage{graphicx}
\usepackage{hyperref}
\hypersetup{
    colorlinks,
    citecolor=black,
    filecolor=black,
    linkcolor=black,
    urlcolor=black
}
\usepackage{tikz-network}
\usepackage{amsmath, amsfonts, amssymb, amsthm}
\usepackage{algpseudocode}
\usepackage{algorithm}
\title{Algortihms and datastructures}
\date{2022}
\author{Kristoffer Klokker}

\usepackage{listings}
\lstset{
  language=XML,
  tabsize=3,
  morekeywords={encoding,
    xs:schema,xs:element,xs:complexType,xs:sequence,xs:attribute}
}


\def\ojoin{\setbox0=\hbox{$\bowtie$}%
  \rule[-.02ex]{.25em}{.4pt}\llap{\rule[\ht0]{.25em}{.4pt}}}
\def\leftouterjoin{\mathbin{\ojoin\mkern-5.8mu\bowtie}}
\def\rightouterjoin{\mathbin{\bowtie\mkern-5.8mu\ojoin}}
\def\fullouterjoin{\mathbin{\ojoin\mkern-5.8mu\bowtie\mkern-5.8mu\ojoin}}
\begin{document}
	\maketitle
	\clearpage
	\tableofcontents
	\clearpage
	\section{Database introduction}
		Databases are a collection of data stored in a DBMS (database management system) which serves the purpose of:
			\begin{itemize}
				\item Create database and specifying their schemas (logical structure of the data)
				\item Query the data (questions about data or retrieving the data)
				\item Store large amount of data in long periods with easy access and modificatio of the data
				\item Durable and should be able to recover data in case of error or misuse
				\item Allow multiple user access at once
			\end{itemize}
			Today the norm in database systems are relation databasese which present the data as tables, and the underlying datastructure is not needed for use of the system.\\
			In the case of multiple different database and systems which should be syncronised either a data warehouse is used where a periodically copy of the smaller databases is made. Another approach is a middleware which is a translation between two databases schemes.\\
			A database has mainly two users, admin which can modify the schema using DDL command (data-definition language) which modify the schema by altering the metadata.\\
			The other user being a normal user allowed to do DML command (data-manipulation language). \\
			When a DML command is executed two subsystems are handling the command:
				\subsection{Query compiler}
					The compiler takes the query and creates a query plan (a sequence of actions) and passes it the the execution engine.\\
					A request of data sends data data in tuples to the buffer manager, which is responsible for all data transaction between disk storage and memory\\
					The compiler consist of
					\begin{itemize}
						\item Query parser - which builds a tree from the textual query
						\item Query preprocessor - Sematic check of query to ensure a valid query and transforms the query into algebraic operators
						\item Query optimizer - Transofrm the query to the best avaliable sequence of operation on the actual data based on metadata and schema structure
					\end{itemize}
				\subsection{Transaction manager}
					The transaction manager is used to log for possible recovering and ensuring durablity\\
					Also the transaction has a concurrency-controle manager to ensure a bundle of transaction is executed as they were one unit and locking data when used to ensure no data is wrongly overwritten.\\
					The transaction also manages such that every execution is isolated in case of revertion.\\
					The transaction followed the ACID test, where
					\begin{itemize}
						\item A - atomicity which ensures that in case of error a transaction is never half completed
						\item C - consistency in data and data constraints
						\item I - isolation ofe ach operation done in order in a transaction
						\item D - durability of data such it is never lost after a transaction
					\end{itemize}
	\section{The relational model of data}
		A data model is used for describing data and conisist of:
		\begin{itemize}
			\item Structure of data - Referred to as physical data model, but is simply a high level data structure
			\item Operations on the data - A limited set of operations in DBS at hight level, which makes it more flexible for underlying improvements
			\item Constraints of data - Constraints on data to ensure data integrity
		\end{itemize} 
		\subsection{The semistructured-data model}
			The data is setup in a relation more like a tree rather than table.\\
			Here XML is mostly used to represent datam by nested tags.
			\begin{lstlisting}
<Movies>
	<Movie title="Gone with the wind">
		<Year>1939</Year>
		<Length>231</Length>
		<Genre>drama</Genre>
	</Movie>
	<Movie title="Star Wars">
		<Year>1977</Year>
		<Length>124</Length>
		<Genre>sciFi</Genre>
	</Movie>
</Movies>
			\end{lstlisting}
		\subsection{Document Type Definition model}
			This is model based on XML to standify a more text based model of a database. This model focus on all the data types in a database and how they are nested.
			An example is as follows:
			\begin{lstlisting}            
<!DOCTYPE Stars [
	<!ELEMENT Stars (Star*)>
	<!ELEMENT Star (Name, Address+, Movie*)>
	<!ELEMENT Name (#PCDATA)>
	<!ELEMENT ADDRESS (Street, City)>
	<!ELEMENT Street (#PCDATA)>
	<!ELEMENT CITY (#PCDATA)>
	<!ELEMENT Movie EMPTY>
		<!ATLIST Title CDATA #REQUIRED, Genre CDATA #IMPLIED>
]>
		\end{lstlisting}
		Here $\#PCDATA$ is some data for an element and it can here be seen how nesting is allowed by defining star with address wich is also defined later.\\
		Here the database Stars also include any number of star as stated at first.\\
		The last movie is an alternative writing were instead of $<Movie>Hello</Movie>$ the $EMPTY$ makes it be $<Movie Title="Hello", "Comedy">$, $CDATA$ is simply characterData and $\#REQUIRED$ means it must be filled whereas $\#IMPLIED$ is optional.
		\subsection{The basics of relational database}
			Relation refers to the two dimensional table of data.With attributes being the coloumns and rows being a tuple. The tuple is then made of an relations where a relation with attributes are a schema. \\
			A relation is defined by $Name(attribute:type, attribute2: type)$ and a tuple is in the same order and valeis for the given attributes.\\
			Relations comes in sets and not lists and therefore order is not important\\
			A database may contain a key which is attribute(s) which define a unique relation, if no combination of attributes are unique a ID for the relation can be created.\\
		\subsection{SQL language}
			SQL is the language used to create queries. SQL has tree kinds of relations, stored called tables (relations), views (relation which are not stored but used for computation), temporary tables (tables constructed by SQL temporary)\\
			The data types avaliable by SQL are:
			\begin{itemize}
				\item $CHAR(n)$ - Character string of fixed length $n$
				\item $BIT$ - Logical value with possible values being TRUE, FALSE, UNKNOWN
				\item $INT$ - Number can also be $SHORTINT$ for small number
				\item $FLOAT$ - Higher precision numbers here $DOUBLE$ can also be used for more precision
				\item $DECIMAL(n,d)$ - Numbers of length $n$ and the decinam placed at $d$
				\item $DATE$ and $TIME$ - both essentially being strings with a strict format
			\end{itemize}
			The basic commands for modifying tables are:
			\begin{itemize}
				\item DROP TABLE R; which removes the table $R$ with all its entries
				\item ALTER TABLE R ADD a type; Adds attribute $a$ as a $type$ to table $R$
				\item ALTER TALBE R DROP a; Removes the attribute $a$ form table $R$
			\end{itemize}
			SQL also has $DEFAULT$ which can be added after any attribute after type and describes the default value if non is given.\\
			\subsubsection{Keys}
				A PRIMARY KEY is used for securing no dublicates and only allows non null values in the key attribute.\\
				UNIQUE allows null as a value in its attribute, but dublicates is still nto allowed.\\
				When creating a table the key can be choosen by after an attribute after its type $PRIMARY\; KEY$ or $UNIQUE$ is inserted or at the end of the table definition $PRIMARY\; KEY\; (a)$ can be inserted where a are the attributes. Again Unique can also be used like this.
	\section{Algebraic Query Language}
		The algebraic query langauge is the operation behind the SQL real language.\\
		This is not a programming language, but the simplicity makes in easier to optimize and faster.\\
		All the operations works on boths sets and bags(the allowance of mutliple accourences of tuples)\\
		The following table is in precedence order from first at top and last on bottom.\\
		\begin{table}[h!]
		\begin{tabular}{|l|l|l|l|}
		\hline
		Name       & Symbol               & Effect                                                                                                      & * \\ \hline
		Selection  & $\sigma_C(R)$         & Select tuples from R which meets the condition $C$                                                          &             \\ \hline
		Projection & $\pi_{A1,A2}(R)$     & All tuples from R but only attributes $A1$ and $A2$                                                         &        4     \\ \hline
		Rename     & $\rho_{S(A1,A2)}(R)$ & \begin{tabular}[c]{@{}l@{}}All tuples in R but rename attributes to A1 and A2\\ Alternative $R2_{A1,A2}:=R$\end{tabular}   & \\ \hline
		Duplicate Elem.  & $\delta (R)$            & Eliminate dublicate tubles in relation R                                                                            &            \\ \hline
		Aggregation  & Ex. $SUM(B)$            & Computes operation on given attribute B                                                                           &         3   \\ \hline
		Group  & $\gamma_{B,SUM(C)\rightarrow s}R $   &\begin{tabular}[c]{@{}l@{}}Group relation R by attribute B and in this\\ example creates attribute s with the sum of\\ attribute C to each goup\end{tabular}                                                &            \\ \hline
		Sort  & $\tau_{A1,A2}(R) $   &Sort relation R according to A1 and A2 &            \\ \hline
		Cartesian  & $R\times S$          & Every possible combination of tuples from R and S                                                           & 2           \\ \hline
		Nat. join  & $R\bowtie S$         & \begin{tabular}[c]{@{}l@{}}Cartesian product but only\\ where overlapping attributes are equal\end{tabular} & 2           \\ \hline
		Theta join & $R\bowtie_CS$        & \begin{tabular}[c]{@{}l@{}}Every cartesian product of R and S\\ which meet the $C$ condition\end{tabular}   & 2           \\ \hline
		Outer join & $R \fullouterjoin S$ & \begin{tabular}[c]{@{}l@{}}Nat. join but none joined tubles, are padded\\ with NULL/$\bot$. Also in variations\\ of $\leftouterjoin$ where only all tubles from R is kept,\\ and $\rightouterjoin$ which keep all from S \end{tabular}  &            \\ \hline
		Difference & $R- S$               & Tuples which in R which is not in S                                                                         & 1           \\ \hline		
		Union      & $R\cup S$            & All tuples from R and S                                                                                     & 1           \\ \hline
		Intersect  & $R\cap S$            & Tuples which are in both R and S                                                                            & 1           \\ \hline
		\end{tabular}
		\end{table}
		\begin{enumerate}
			\item Same attributes (and same type) in same order
			\item In case of attributes with same name they will be "renamed" to 'relationName.Attribute'
			\item The standard aggreagation operations are: SUM,AVG,MIN,MAX,COUNT
			\item Attribute A1 can also be 'A1 $rightarrow$ k' for renaming it to, or some expression like 'A1 + A2 $\rightarrow$ sum'
		\end{enumerate}
		It can here be seen that there is multiple combinations which are equal. Here the highest priority readability due to the query compiler rewriting it anyway.\\
		When writing linear notation be used as such:
		$$R(a,y,l):=\sigma_{age<18}(People)$$
		From which $R$ now can be usedas a variable.\\
		Often when combining operationsa tree is used where root is the final product and branches are the first operations done.
		\subsection{Examples}
			\begin{minipage}[t]{0.32\textwidth}
				\begin{center}
				$A$\\
				\begin{tabular}{|l|l|}
				\hline
				A & B \\ \hline
				1 & 5 \\ \hline
				2 & 4 \\ \hline
				\end{tabular}\\[4mm]
				$A\cup C$\\
				\begin{tabular}{|l|l|}
				\hline
				A & B \\ \hline
				1 & 5 \\ \hline
				2 & 4 \\ \hline
				1 & 5 \\ \hline
				7 & 0 \\ \hline
				\end{tabular}\\[4mm]
				$\sigma_{B<4}(C)$\\
				\begin{tabular}{|l|l|}
				\hline
				A & B \\ \hline
				7 & 0 \\ \hline
				\end{tabular}\\[4mm]
				$A\bowtie B$\\
				\begin{tabular}{|l|l|l|}
				\hline
				 A & B & C \\ \hline
				 1 & 5 & 8 \\ \hline
				 2 & 4 & 9 \\ \hline
				\end{tabular}
				
				\end{center}
			\end{minipage}
			\begin{minipage}[t]{0.32\textwidth}
				\begin{center}
				$B$\\
				\begin{tabular}{|l|l|}
				\hline
				B & C \\ \hline
				5 & 8 \\ \hline
				4 & 9 \\ \hline
				\end{tabular}\\[4mm]
				$A\cap C$\\
				\begin{tabular}{|l|l|}
				\hline
				A & B \\ \hline
				1 & 5 \\ \hline
				\end{tabular}\\[4mm]
				$\pi_B(A)$\\
				\begin{tabular}{|l|}
				\hline
				 B \\ \hline
				 5 \\ \hline
				 4 \\ \hline
				\end{tabular}\\[4mm]
				$A\bowtie_{A.B = B.B}C$\\
				\begin{tabular}{|l|l|l|l|}
				\hline
				A & A.B & B.B & C \\ \hline
				1 & 5 & 5 & 8\\ \hline
				2 & 4 & 4 & 9\\ \hline
				\end{tabular}
				\end{center}				
			\end{minipage}
			\begin{minipage}[t]{0.32\textwidth}
				\begin{center}
				$C$\\
				\begin{tabular}{|l|l|}
				\hline
				A & B \\ \hline
				1 & 5 \\ \hline
				7 & 0 \\ \hline
				\end{tabular}\\[4mm]
				$A- C$\\
				\begin{tabular}{|l|l|}
				\hline
				A & B \\ \hline
				2 & 4 \\ \hline
				\end{tabular}\\[4mm]
				$A\times B$\\
				\begin{tabular}{|l|l|l|l|}
				\hline
				A & A.B & B.B & C \\ \hline
				1 & 5 & 5 & 8\\ \hline
				1 & 5 & 4 & 9\\ \hline
				2 & 4 & 5 & 8\\ \hline
				2 & 4 & 4 & 9\\ \hline
				\end{tabular}\\[4mm]
				$\rho_{G,K}(A)$\\
				\begin{tabular}{|l|l|}
				\hline
				G & K \\ \hline
				1 & 5 \\ \hline
				2 & 4 \\ \hline
				\end{tabular}
				\end{center}				
			\end{minipage}
	\section{Queries in SQL}
		\subsection{Select}
			The most simple query is the SELECT FROM WHERE.\\
			This a simple select query which selects attributes from a database where a conditions is met.\\
			The conditions can use the 6 comparisions operators: $=,<>,<,>,<=,>=$ where $<>$ is not equal.\\
			Operations may also be done on values for int $+,-,*,/,\%$ and for string $||$ which adds two string together.\\
			When comparing string the $<$ operators are defined upon lexicongraphic order.\\
			For string the LIKE can be used to match a pattern. A pattern uses $\%$ and $\_$ where $\%$ is any number of wildcard charachters and $\_$ is a single charachter.\\
			Strings are defined by ' therefore when working with them inside a string two ' is used like ''\\
			Logic operators avaliable is AND, OR and NOT\\
			Ex. SELECT title, genre FROM Books WHERE author = Kristoffer Klokker AND year = 2022\\
		\subsection{Default}
			When creating a realtion, the default attribute can be used in case of a not given value.\\
			CREATE TABLE CoolPeople(name CHAR(30) DEFAULT 'Kristoffer Klokker', phone CHAR(16));
		\subsection{Modifying the database}
			\subsubsection{Insert}
				INSERT INTO R VALUES (A1,A2..)\\
				Insert a tuble into relation R with values A1, A2 as the attributes in same order.\\
				Alternative INSERT INTO R(Sum,Name) VALUES (A1,A2..), which will insert the value to the corresponding attrubute.\\
				A1 and A2 can also be a tubles by itself from another DB, for inserting multiple tubles at once.
			\subsubsection{Deletion}
				DELETE FROM R WHERE <condition>\\
				Delete every tuple in relation R which satifies the condition.\\
				Remember deletion is not a linear process rather all satifiable tuples will be deleted once all are found.
			\subsection{Update}
				UPDATE R SET name = 'Kristofer' WHERE <condition>\\
				Changes attribute value, where the condition is met.
		\subsection{Rename}
			In case of a rename of attributes the keywords AS is used, here it is also possible to modify values.\\
			Ex. SELECT title + ' and the stone' AS name from Books\\
			COnstants are also avaliable if wanted.\\
			Ex. SELECT title || ' and the stone' AS name, 'forever' AS readTime from Books\\
		\subsection{Date and time}
			Dates are defined as: DATE 'year-month-day' Ex: DATE '2022-12-04'\\
			Times are defined as: TIME 'hour:minut:second' Ex: TIME '19:42:12.55'\\
			In case of timezones TIME 'hour:minut:second-hour:minut' this will be the amount of hours and minuts behind GMT. The minus could also be a plus.\\
			Timestamps are used to combine date and time.\\
			Timestamps are defined as 'TIMESTAMP 'year-month-day hour:minut:second'\\
			These values can of course be compared both with equal and all the $<$ as expected.
		\subsection{Working with null}
			A sql entry may be null due to: not knowing the value, no value really match the attribute or the value is withheld.\\
			This can have consequence in the query condition.\\
			When using any math operations on null it becomes null.\\
			When comparing anything to null it becomes UNKNOWN.\\
			To check if a value is null the IS NULL is used.\\
			In the opearation 'UNKNOWN AND x' the statement is false when x is false and UNKNOWN when x is true.\\
			In the operation 'UNKNOWN OR x' the statement is true when x is true and UNKNOWN when x us false.\\
			When negating UNKNOWN the value is UNKNOWN.\\
			UNKNOWN values will not interpretated as true and queries where the condition result in UNKNOWN will not show up.\\
		\subsection{Ordering}
			To order the output of a qeruy the ORDER BY <attributes> is used.\\
			After the attributes list DESC can be added for a descending list whereas ASC is not needed due to ascending being the default.\\
			Multiple attributes are used in case of a the first attribute being equal then the second attribute is used for ordering.
		\subsection{Multiple tables}
			When working with multiple tables the FROM can be filled up with multiple tables.\\
			Ex. SELECT title, age FROM Books CoolPeople WHERE author = name\\
			In case of the table having the same name or the same table being used an alias can be created by a space after the table followed by the wanted name.\\
			Ex. SELECT Book1.name, Book2.name FROM Books Book1, Books Book2 WHERE Book1.title = Book2.title AND Book1.name <> Book2.name\\
		\subsection{Union, intersect and except}
			The relational algebra operation can be used on two SELECT statement to get the expected output.\\
			Ex. SELECT name FROM Books INTERSECT SELECT name FROM CoolPeople\\
			For union and except intersect is replaced with UNION or EXCEPT.\\
			These operations will eliminate dublicates to prevent this the ALL keyword can be used. Ex. SELECT name FROM Books INTERSECT ALL SELECT name FROM CoolPeople\\
		\subsection{Join}
			The simplest join is the CROSS join also known as cartesian product Ex. Books CROSS JOIN CoolPeople\\
			Theta joing the cross product but with a condition is done like cross but with ON and then condition Ex. Books JOIN CoolPeople ON author = name\\
			Natural join where attributes are matched is done by taking the two tables with NATURAL JOIN between Ex. CoolPeople NATRUAL JOIN SmartPeople\\
			Outher join is like natural join except instead of throwing away non matching entries they are filled with null Ex. CoolPople NATURAL FULL OUTER JOIN SmartPeople. \\
			This will include all entries from SmartPeople and CoolPeople but if an entry only exists in one the attributes from the other table is fileld with null.\\
			Variant of LEFT and RIGHT also where left only includes all entries from the left table and only matching from the right Ex. CoolPeople NATURAL LEFT OUTER JOIN SmartPeople.\\
		 \subsection{Subqueries}
		 	Subqueries are used for getting a value from a table which then is most often used in a comapre statement or as a table the selection is taken from.\\
		 	If a subquery only return one value it is called scalar and can be used in an condition.\\
		 	Ex SELECT title FROM Books Where author = (SELECT name FROM CoolPeople WHERE key = 3)\\
		 	In case a subquery return multiple result the following operators can be used:
		 	\begin{itemize}
		 		\item EXISTS R - return true if R is not empty
		 		\item s IN R - return true if s is an entry in R
		 		\item s ($>$) ALL R - returns true if the math operation here $>$ is true for all entried in R
		 		\item s ($>$) ANY R - returns true if the math operation here $>$ is true for any entru in R
			\end{itemize}
			All the operators can ofcourse be negated by puttin NOT infront.
		\subsection{Sets}
			To get a set in a query the DISTINCT is used after the SELECT Ex. SELECT DISTINCT names FROM...\\
		\subsection{Aggregation operations}
			This is operations which is done on the while selection.\\
			These operations include: SUM, AVG, MIN, MAX and COUNT.\\
			Ex. SELECT AVG(age) FROM CoolPeople\\
			In case of wanting only sets DISTINCT is used as follow SELECT SUM(DISTINCT age) FROM CoolPeople.\\
			GROUP BY is often here used to get the aggregation to a given group.
			Ex. SELECT name, SUM(age) FROM CoolPeople GROUP BY name.\\
			This will give the age sum for each name in cool people.\\
			NULL is ignored when calcilation an aggregation but a group can be in NULL.\\
			THE GROUP BY can also works as a condition with the keyword HAVING.\\
			Ex. SELECT name, SUM(age) FROM CoolPeople GROUP BY name HAVING MIN(age) $>$ 18\\
			This will return the names and the sum of ages with the same name but only people over 18 count.
			
		
\end{document}
