\documentclass[12pt, a4paper]{article}
\usepackage{caption}
\usepackage{graphicx}
\usepackage{hyperref}
\hypersetup{
    colorlinks,
    citecolor=black,
    filecolor=black,
    linkcolor=black,
    urlcolor=black
}
\usepackage{tikz-network}
\usepackage{amsmath, amsfonts, amssymb, amsthm}
\usepackage{algpseudocode}
\usepackage{algorithm}
\title{Algortihms and datastructures}
\date{2022}
\author{Kristoffer Klokker}

\usepackage{listings}
\lstset{
  language=XML,
  tabsize=3,
  morekeywords={encoding,
    xs:schema,xs:element,xs:complexType,xs:sequence,xs:attribute}
}
\begin{document}
	\maketitle
	\clearpage
	\tableofcontents
	\clearpage
	\section{Database introduction}
		Databases are a collection of data stored in a DBMS (database management system) which serves the purpose of:
			\begin{itemize}
				\item Create database and specifying their schemas (logical structure of the data)
				\item Query the data (questions about data or retrieving the data)
				\item Store large amount of data in long periods with easy access and modificatio of the data
				\item Durable and should be able to recover data in case of error or misuse
				\item Allow multiple user access at once
			\end{itemize}
			Today the norm in database systems are relation databasese which present the data as tables, and the underlying datastructure is not needed for use of the system.\\
			In the case of multiple different database and systems which should be syncronised either a data warehouse is used where a periodically copy of the smaller databases is made. Another approach is a middleware which is a translation between two databases schemes.\\
			A database has mainly two users, admin which can modify the schema using DDL command (data-definition language) which modify the schema by altering the metadata.\\
			The other user being a normal user allowed to do DML command (data-manipulation language). \\
			When a DML command is executed two subsystems are handling the command:
				\subsection{Query compiler}
					The compiler takes the query and creates a query plan (a sequence of actions) and passes it the the execution engine.\\
					A request of data sends data data in tuples to the buffer manager, which is responsible for all data transaction between disk storage and memory\\
					The compiler consist of
					\begin{itemize}
						\item Query parser - which builds a tree from the textual query
						\item Query preprocessor - Sematic check of query to ensure a valid query and transforms the query into algebraic operators
						\item Query optimizer - Transofrm the query to the best avaliable sequence of operation on the actual data based on metadata and schema structure
					\end{itemize}
				\subsection{Transaction manager}
					The transaction manager is used to log for possible recovering and ensuring durablity\\
					Also the transaction has a concurrency-controle manager to ensure a bundle of transaction is executed as they were one unit and locking data when used to ensure no data is wrongly overwritten.\\
					The transaction also manages such that every execution is isolated in case of revertion.\\
					The transaction followed the ACID test, where
					\begin{itemize}
						\item A - atomicity which ensures that in case of error a transaction is never half completed
						\item C - consistency in data and data constraints
						\item I - isolation ofe ach operation done in order in a transaction
						\item D - durability of data such it is never lost after a transaction
					\end{itemize}
	\section{The relational model of data}
		A data model is used for describing data and conisist of:
		\begin{itemize}
			\item Structure of data - Referred to as physical data model, but is simply a high level data structure
			\item Operations on the data - A limited set of operations in DBS at hight level, which makes it more flexible for underlying improvements
			\item Constraints of data - Constraints on data to ensure data integrity
		\end{itemize} 
		\subsection{The semistructured-data model}
			The data is setup in a relation more like a tree rather than table.\\
			Here XML is mostly used to represent datam by nested tags.
			\begin{lstlisting}
<Movies>
	<Movie title="Gone with the wind">
		<Year>1939</Year>
		<Length>231</Length>
		<Genre>drama</Genre>
	</Movie>
	<Movie title="Star Wars">
		<Year>1977</Year>
		<Length>124</Length>
		<Genre>sciFi</Genre>
	</Movie>
</Movies>
			\end{lstlisting}
		\subsection{Document Type Definition model}
			This is model based on XML to standify a more text based model of a database. This model focus on all the data types in a database and how they are nested.
			An example is as follows:
			\begin{lstlisting}            
<!DOCTYPE Stars [
	<!ELEMENT Stars (Star*)>
	<!ELEMENT Star (Name, Address+, Movie*)>
	<!ELEMENT Name (#PCDATA)>
	<!ELEMENT ADDRESS (Street, City)>
	<!ELEMENT Street (#PCDATA)>
	<!ELEMENT CITY (#PCDATA)>
	<!ELEMENT Movie EMPTY>
		<!ATLIST Title CDATA #REQUIRED, Genre CDATA #IMPLIED>
]>
		\end{lstlisting}
		Here $\#PCDATA$ is some data for an element and it can here be seen how nesting is allowed by defining star with address wich is also defined later.\\
		Here the database Stars also include any number of star as stated at first.\\
		The last movie is an alternative writing were instead of $<Movie>Hello</Movie>$ the $EMPTY$ makes it be $<Movie Title="Hello", "Comedy">$, $CDATA$ is simply characterData and $\#REQUIRED$ means it must be filled whereas $\#IMPLIED$ is optional.
		\subsection{The basics of relational database}
			Relation refers to the two dimensional table of data.With attributes being the coloumns and rows being a tuple. The tuple is then made of an relations where a relation with attributes are a schema. \\
			A relation is defined by $Name(attribute:type, attribute2: type)$ and a tuple is in the same order and valeis for the given attributes.\\
			Relations comes in sets and not lists and therefore order is not important\\
			A database may contain a key which is attribute(s) which define a unique relation, if no combination of attributes are unique a ID for the relation can be created.\\
		\subsection{SQL language}
			SQL is the language used to create queries. SQL has tree kinds of relations, stored called tables (relations), views (relation which are not stored but used for computation), temporary tables (tables constructed by SQL temporary)\\
			The data types avaliable by SQL are:
			\begin{itemize}
				\item $CHAR(n)$ - Character string of fixed length $n$
				\item $BIT$ - Logical value with possible values being TRUE, FALSE, UNKNOWN
				\item $INT$ - Number can also be $SHORTINT$ for small number
				\item $FLOAT$ - Higher precision numbers here $DOUBLE$ can also be used for more precision
				\item $DECIMAL(n,d)$ - Numbers of length $n$ and the decinam placed at $d$
				\item $DATE$ and $TIME$ - both essentially being strings with a strict format
			\end{itemize}
			The basic commands for modifying tables are:
			\begin{itemize}
				\item DROP TABLE R; which removes the table $R$ with all its entries
				\item ALTER TABLE R ADD a type; Adds attribute $a$ as a $type$ to table $R$
				\item ALTER TALBE R DROP a; Removes the attribute $a$ form table $R$
			\end{itemize}
			SQL also has $DEFAULT$ which can be added after any attribute after type and describes the default value if non is given.\\
			\subsubsection{Keys}
				A PRIMARY KEY is used for securing no dublicates and only allows non null values in the key attribute.\\
				UNIQUE allows null as a value in its attribute, but dublicates is still nto allowed.\\
				When creating a table the key can be choosen by after an attribute after its type $PRIMARY\; KEY$ or $UNIQUE$ is inserted or at the end of the table definition $PRIMARY\; KEY\; (a)$ can be inserted where a are the attributes. Again Unique can also be used like this.
	\section{Algebraic Query Language}
		The algebraic query langauge is the operation behind the SQL real language.\\
		This is not a programming language, but the simplicity makes in easier to optimize and faster.\\
		All the operations works on boths sets and bags(the allowance of mutliple accourences of tuples)\\
		The following table is in precedence order from first at top and last on bottom.\\
		\begin{table}[h!]
		\begin{tabular}{|l|l|l|l|}
		\hline
		Name       & Symbol               & Effect                                                                                                      & * \\ \hline
		Selection  & $\sigma_C(R)$         & Select tuples from R which meets the condition $C$                                                          &             \\ \hline
		Projection & $\pi_{A1,A2}(R)$     & All tuples from R but only attributes $A1$ and $A2$                                                         &             \\ \hline
		Rename     & $\rho_{S(A1,A2)}(R)$ & \begin{tabular}[c]{@{}l@{}}All tuples in R but rename attributes to A1 and A2\\ Alternative $R2_{A1,A2}:=R$\end{tabular}   & \\ \hline
		Cartesian  & $R\times S$          & Every possible combination of tuples from R and S                                                           & 2           \\ \hline
		Nat. join  & $R\bowtie S$         & \begin{tabular}[c]{@{}l@{}}Cartesian product but only\\ where overlapping attributes are equal\end{tabular} & 2           \\ \hline
		Theta join & $R\bowtie_CS$        & \begin{tabular}[c]{@{}l@{}}Every cartesian product of R and S\\ which meet the $C$ condition\end{tabular}   & 2           \\ \hline
		Difference & $R- S$               & Tuples which in R which is not in S                                                                         & 1           \\ \hline		
		Union      & $R\cup S$            & All tuples from R and S                                                                                     & 1           \\ \hline
		Intersect  & $R\cap S$            & Tuples which are in both R and S                                                                            & 1           \\ \hline
		\end{tabular}
		\end{table}
		\begin{enumerate}
			\item Same attributes (and same type) in same order
			\item In case of attributes with same name they will be "renamed" to 'relationName.Attribute'
		\end{enumerate}
		It can here be seen that there is multiple combinations which are equal. Here the highest priority readability due to the query compiler rewriting it anyway.\\
		When writing linear notation be used as such:
		$$R(a,y,l):=\sigma_{age<18}(People)$$
		From which $R$ now can be usedas a variable.\\
		Often when combining operationsa tree is used where root is the final product and branches are the first operations done.
		\subsection{Examples}
			\begin{minipage}[t]{0.32\textwidth}
				\begin{center}
				$A$\\
				\begin{tabular}{|l|l|}
				\hline
				A & B \\ \hline
				1 & 5 \\ \hline
				2 & 4 \\ \hline
				\end{tabular}\\[4mm]
				$A\cup C$\\
				\begin{tabular}{|l|l|}
				\hline
				A & B \\ \hline
				1 & 5 \\ \hline
				2 & 4 \\ \hline
				1 & 5 \\ \hline
				7 & 0 \\ \hline
				\end{tabular}\\[4mm]
				$\sigma_{B<4}(C)$\\
				\begin{tabular}{|l|l|}
				\hline
				A & B \\ \hline
				7 & 0 \\ \hline
				\end{tabular}\\[4mm]
				$A\bowtie B$\\
				\begin{tabular}{|l|l|l|}
				\hline
				 A & B & C \\ \hline
				 1 & 5 & 8 \\ \hline
				 2 & 4 & 9 \\ \hline
				\end{tabular}
				
				\end{center}
			\end{minipage}
			\begin{minipage}[t]{0.32\textwidth}
				\begin{center}
				$B$\\
				\begin{tabular}{|l|l|}
				\hline
				B & C \\ \hline
				5 & 8 \\ \hline
				4 & 9 \\ \hline
				\end{tabular}\\[4mm]
				$A\cap C$\\
				\begin{tabular}{|l|l|}
				\hline
				A & B \\ \hline
				1 & 5 \\ \hline
				\end{tabular}\\[4mm]
				$\pi_B(A)$\\
				\begin{tabular}{|l|}
				\hline
				 B \\ \hline
				 5 \\ \hline
				 4 \\ \hline
				\end{tabular}\\[4mm]
				$A\bowtie_{A.B = B.B}C$\\
				\begin{tabular}{|l|l|l|l|}
				\hline
				A & A.B & B.B & C \\ \hline
				1 & 5 & 5 & 8\\ \hline
				2 & 4 & 4 & 9\\ \hline
				\end{tabular}
				\end{center}				
			\end{minipage}
			\begin{minipage}[t]{0.32\textwidth}
				\begin{center}
				$C$\\
				\begin{tabular}{|l|l|}
				\hline
				A & B \\ \hline
				1 & 5 \\ \hline
				7 & 0 \\ \hline
				\end{tabular}\\[4mm]
				$A- C$\\
				\begin{tabular}{|l|l|}
				\hline
				A & B \\ \hline
				2 & 4 \\ \hline
				\end{tabular}\\[4mm]
				$A\times B$\\
				\begin{tabular}{|l|l|l|l|}
				\hline
				A & A.B & B.B & C \\ \hline
				1 & 5 & 5 & 8\\ \hline
				1 & 5 & 4 & 9\\ \hline
				2 & 4 & 5 & 8\\ \hline
				2 & 4 & 4 & 9\\ \hline
				\end{tabular}\\[4mm]
				$\rho_{G,K}(A)$\\
				\begin{tabular}{|l|l|}
				\hline
				G & K \\ \hline
				1 & 5 \\ \hline
				2 & 4 \\ \hline
				\end{tabular}
				\end{center}				
			\end{minipage}
	\section{Design theory for Relational Databases}
		\subsection{Functional dependencies}
			A functional dependecy is defined as:
			$$A_1,A_2,...,A_n \rightarrow B_1,B_2,...,B_n$$
			Functional dependecies are constraints on a relation which states: \\
			If two tuples agree on the $A$ attributes of the dependency they must agree on the $B$ attributes\\
			The transitive rule states for the FDs $A\rightarrow B$ and $B\rightarrow C$ will $A\rightarrow C$ be true.\\
			The splitting combining rule states for the FD $A\rightarrow BC$, it can be spliited into $A\rightarrow B$ and $A\rightarrow C$, or combined the other way around.\\
			The trivial FD for the attribute $A$ is $A\rightarrow A$.\\
			A basis of FD's are just the given FD's\\
			The minimal basis of FD's are only singletons, and removing any FD will not be equivalent to the basis.\\ 
		\subsubsection{Keys}
			A key is a minimal set of attributes which will be unique for every set of attributes.\\
			$$\{A_1,A_2,...,A_n\}$$
			Here the attributes are part of the key.\\
			\textbf{Superkey}: A set of attributes of which one is a key.\\
			Some uses the terminology where key is not minimal and candidate key is minimal.\\
		\subsubsection{Closures}
				  A closure for the attribute $A$, is all attributes, which can be computed from which $\{A\}^+\rightarrow \{A,B,C\}$, from the singletons $A\rightarrow B$ and $B\rightarrow C$\\
				  The closure is found by starting with the trivial, then FD's which include the derived attributes is inserted until no more informations from FD's can be added.\\
				  The closure of $\{superKey\}^+$ will result in all attributes.\\
				  The colsure of $\{key\}^+$ will also result in all attributes, but no attribute of the key can be removed.\\
				  Projecting FD's onto a new relation with a limited amount attributes, will only the FD's which involves the new relation hold.
	\section{Designing a Database}
		\subsection{Anomalies}
			Anomailies are repeated information in multiple tuplees.\\
			The can lead to lost of data, if repeated data turns out to be the last data when deleted or non updated values for all repeated data.\\
			To prevent this decomposing relations can be done\\
			This is where all the repeated data is in one relation, and the none repated attribute is in another relation with key also.\\
		\subsection{Boyce-Codd Normal Form}
			To decompose the relation Boyce-Codd Normal form (BCNF) is used.\\
			This is a rule which states, that for all FD's in the relations the left sides should be part of the super key.\\
			So the the relation $R(A,B,C)$ with the FD's $A\rightarrow B$ and $A\rightarrow C$, will $A$ be the super key.\\
			This relation will therefore be decomposible into two relations $R(A,B)$ and $R(A,C)$.\\
			It can here be noted that, transitive relations may be used.\\
			Example the relation $R(A,B,C,D)$ with the FD's $A\rightarrow B$, $B\rightarrow C$ and $B\rightarrow D$.\\
			It can here be seen $A$ is the key due to being the only attribute from which all other attributes can be found.\\
			Therefore the relation can be described in two relations $R(A,B)$,$R(B,C,D)$. Here BCNF will hold.\\
			Performing a decompose of $R$ using $X\rightarrow Y$, is done by having $R_1=X^+$ and $R_2=R-(X^+-X)$\\
			The third normal form is a modification of BCNF where the FD $X\rightarrow A$ is only a violation if $X$ is not a superkey and $A$ is prime (member of a key).\\
			3NF can be smart due to it will always preserve FD's, which BCNF does not gurantee.
			\subsubsection{Decompositiong with 3NF}
				First all FD's are splitted. Then the FD's are simplified or removed if repeated.\\
				Then the candidate key is all, keys on the right of the FD's clousing sets.\\
				The relations will then be the simplified / minmal basis of FD's.
		\subsection{Valid decompose}
			A measure if the decomposition is correct, is if when the natural join is performed on the given decomposed relations, we shall get the original relation back with the same number of tuples and correct tuples.\\
			The case method, consist of writing a tablau, with a row representing a decomposed relation. Then the row is filled with know values and unknown valeus are subscribted with the row number.\\
			Then from the FD's the rows should be able to be combined by finding equal variables from which the subscribted variables are removed, ending up with a row with no subscribted values.
				\end{document}
